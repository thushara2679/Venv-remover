- Variables, functions, modules, and file names must use snake_case. Class and Type names must use PascalCase. All module-level constants must use SCREAMING_SNAKE_CASE (e.g., MAX_RETRIES).
- No script file shall exceed 600 lines of code. If a script naturally grows beyond this limit, refactor its contents into modular scripts based on distinct functionality (e.g., data_processing.py, api_handlers.py). The original file should be converted to a centralized coordination script that imports and orchestrates the functions from the new modules.
- Create a folder named utils/.
- Move the sanitize_sheet_name function (and likely other similar helper functions) into a Python file within the utils/ folder (e.g., utils/name_helpers.py).
- All non-exported, reusable, or project-specific utility functions must be placed within a dedicated utils/ folder. Organize this folder logically (e.g., utils/data_helpers.py, utils/string_formatters.py).
- No single function body shall exceed 150 lines of executable code. If a function's complexity demands more, it must be broken down into smaller, well-named sub-functions (e.g., main function calls _validate_input(), _process_data(), _save_to_db()).
- For the tvdatafeed library, always use the direct GitHub source installation command: pip install git+https://github.com/rongardF/tvdatafeed.git. Do not use pip install tvdatafeed.
- For extracting data from websites, utilize Data Scrapy methods and robust web scrapers (like Scrapy, BeautifulSoup, or Playwright). Do not use generic website APIs unless explicitly instructed or if the API is officially provided by the data source.
- Exclusively use async/await for all asynchronous operations. The use of promise chaining (.then(), .catch(), .finally()) is strictly prohibited.
- All web application styling must use Tailwind CSS utility classes. Custom CSS files, raw SASS/SCSS, or other frameworks (Bootstrap, Bulma) are forbidden.
- All user input (from forms, API requests, or CLI) must be sanitized, validated, and type-checked immediately upon receipt and before saving to the DB or using in any operation. Use language-appropriate libraries (e.g., bleach in Python) to prevent XSS and other injection attacks.
- All database queries must use parameterized statements (prepared statements). Never construct SQL queries using string concatenation with raw user input.
- API keys, database credentials, and other secrets must only be loaded from environment variables (e.g., .env file via dotenv) or a secure vault system. They must never be hardcoded into the source code.
- All public-facing API endpoints must implement a request rate-limiting mechanism. This must be applied per IP address or authenticated user ID.
- Before adding a new dependency, the agent must check the security status of the package (e.g., check for known CVEs) and must prefer well-maintained, popular libraries.
- All exported functions, classes, and public methods must include JSDoc (or Python Docstrings/equivalent) comments. These must include: Purpose, @param (name, type, description), @returns (type, description), and @throws (error type, condition).
- Use inline comments sparingly and only to explain why the code is doing something complex, not what it's doing. Code should be self-explanatory where possible.
- Any new modular script must be added to the project's README.md with a brief description of its function. The main README.md must always contain up-to-date installation and usage instructions.
- Do Not Repeat Yourself (DRY). Identify and abstract repeated code blocks into reusable functions in the utils/ folder or shared classes.
- Prefer immutable data structures and objects over mutable ones, especially for function inputs. Avoid modifying function parameters in place.
- Code must be written to be easily testable. Avoid global state, use dependency injection for external resources (DB connections, API clients), and keep business logic separate from I/O.
- Validate input and check for error conditions early in a function's execution. Throw exceptions immediately upon detecting invalid state instead of continuing execution.
- All table and column names must be snake_case (e.g., user_account). Table names must be plural (e.g., users, orders).
- Primary keys must be named id (e.g., users.id). Foreign keys must be named in the format [related_table]_id (e.g., user_id, product_id).
- Database schema changes must always be managed via dedicated, version-controlled migration scripts. The agent must generate both the code changes and the corresponding migration script. Never make direct, unlogged manual schema changes.
- All external API interactions (including custom integrations) must be encapsulated in a dedicated Service or Client class/module (e.g., StripeClient, AuthService). This module must handle connection, authentication, retries, and rate limiting.
- All external API call errors must be caught and translated into a standardized internal error format. Do not expose raw external API error messages or codes to end-users.
- When building a custom API connection, design an abstraction layer (interface/protocol) first that defines the required methods (e.g., get_user_info, send_payment). The actual implementation should adhere to this abstraction.
- When performing error-fixing, debugging, or minor feature additions, the change set must be narrowly scoped to the affected functionality. Do not alter other core processes, configuration, or unrelated business logic in the existing code.
- For every new feature or bug fix, the agent must first generate the required unit or integration test (which will initially fail) before writing the implementation code.
- When creating a new script file, the next task is always to create a separate, isolated, and individual testing environment/harness (e.g., a simple test_script_name.py or a dedicated unit test). The agent must confirm the script's correct functionality and desired output before proceeding to generate the next file or integrate the script into the main program flow. If a failure occurs, the agent must fix and re-test immediately until correct functionality and desired output.
- Before final integration, all newly generated scripts must be run in an isolated environment to verify correct functionality and desired output. If the test fails, fix it immediately, then re-test.
- A Test_py/ folder must be created, and unit tests (using a framework like unittest or pytest) must be written for all critical functions in the codebase.
- All test files must be placed in the Test_py/ folder. Test cases must be written and validated in the Test_py/ directory BEFORE implementing the corresponding functionality in the main program. Follow test-first development: write test → run test (should fail) → implement feature → run test (should pass) → integrate to main program.

- Every function must be updated to include a properly formatted docstring immediately after the function definition.
- The README.md file must be updated to include clear, step-by-step documentation on how to use the code, which may include examples, required command-line arguments, or configuration details.
- create prompt_context_log.md file in the .clinerules folder if the prompt_context_log.md file is not existing.

# PROMPT CONTEXT LOGGING INSTRUCTION
# Goal: Mimic caching/memory for tasks exceeding a single prompt.

After successfully completing any complex task or a task that involves multiple back-and-forth prompts, you must write a brief, high-level summary of:
1. The *Task Goal* (e.g., "Implement user authentication with JWT").
2. The *Key Decisions Made* (e.g., "Used bcrypt for password hashing. JWT token expires after 1 hour.").
3. The *Files Changed/Created* (e.g., "Created users_model.py, auth_handler.py, and updated main.py").
4. 

Append this summary to the file **prompt_context_log.md** in .clinerules folder using the following Markdown format:

---
## Task: [Task Goal Here] (Date: YYYY-MM-DD)
- **Outcome:** [Brief description of the resolution/outcome.]
- **Key Files:** [List of files, e.g., users_model.py, auth_handler.py]
- **Summary:** [technical summary of the implementation details/architecture changes. ]
- **Prompt:** [Create a prompt for generating this APP again using a AI generator without missing any part.]

---

Before starting any new, related task, the first action must be to **reference this file** in the chat using the @mention command: **`@prompt_context_log.md`**. This ensures the log content is added to your current context.


